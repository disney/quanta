// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.0
// source: quanta.proto

package shared

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ClusterAdmin_Status_FullMethodName   = "/shared.ClusterAdmin/Status"
	ClusterAdmin_Shutdown_FullMethodName = "/shared.ClusterAdmin/Shutdown"
)

// ClusterAdminClient is the client API for ClusterAdmin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterAdminClient interface {
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusMessage, error)
	Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type clusterAdminClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterAdminClient(cc grpc.ClientConnInterface) ClusterAdminClient {
	return &clusterAdminClient{cc}
}

func (c *clusterAdminClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusMessage, error) {
	out := new(StatusMessage)
	err := c.cc.Invoke(ctx, ClusterAdmin_Status_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterAdminClient) Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ClusterAdmin_Shutdown_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterAdminServer is the server API for ClusterAdmin service.
// All implementations should embed UnimplementedClusterAdminServer
// for forward compatibility
type ClusterAdminServer interface {
	Status(context.Context, *emptypb.Empty) (*StatusMessage, error)
	Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedClusterAdminServer should be embedded to have forward compatible implementations.
type UnimplementedClusterAdminServer struct {
}

func (UnimplementedClusterAdminServer) Status(context.Context, *emptypb.Empty) (*StatusMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedClusterAdminServer) Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}

// UnsafeClusterAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterAdminServer will
// result in compilation errors.
type UnsafeClusterAdminServer interface {
	mustEmbedUnimplementedClusterAdminServer()
}

func RegisterClusterAdminServer(s grpc.ServiceRegistrar, srv ClusterAdminServer) {
	s.RegisterService(&ClusterAdmin_ServiceDesc, srv)
}

func _ClusterAdmin_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAdminServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAdmin_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAdminServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterAdmin_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterAdminServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ClusterAdmin_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterAdminServer).Shutdown(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ClusterAdmin_ServiceDesc is the grpc.ServiceDesc for ClusterAdmin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClusterAdmin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shared.ClusterAdmin",
	HandlerType: (*ClusterAdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _ClusterAdmin_Status_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _ClusterAdmin_Shutdown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "quanta.proto",
}

const (
	KVStore_Put_FullMethodName                     = "/shared.KVStore/Put"
	KVStore_BatchPut_FullMethodName                = "/shared.KVStore/BatchPut"
	KVStore_Lookup_FullMethodName                  = "/shared.KVStore/Lookup"
	KVStore_BatchLookup_FullMethodName             = "/shared.KVStore/BatchLookup"
	KVStore_Items_FullMethodName                   = "/shared.KVStore/Items"
	KVStore_PutStringEnum_FullMethodName           = "/shared.KVStore/PutStringEnum"
	KVStore_DeleteIndicesWithPrefix_FullMethodName = "/shared.KVStore/DeleteIndicesWithPrefix"
	KVStore_IndexInfo_FullMethodName               = "/shared.KVStore/IndexInfo"
)

// KVStoreClient is the client API for KVStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KVStoreClient interface {
	Put(ctx context.Context, in *IndexKVPair, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BatchPut(ctx context.Context, opts ...grpc.CallOption) (KVStore_BatchPutClient, error)
	Lookup(ctx context.Context, in *IndexKVPair, opts ...grpc.CallOption) (*IndexKVPair, error)
	BatchLookup(ctx context.Context, opts ...grpc.CallOption) (KVStore_BatchLookupClient, error)
	Items(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (KVStore_ItemsClient, error)
	PutStringEnum(ctx context.Context, in *StringEnum, opts ...grpc.CallOption) (*wrapperspb.UInt64Value, error)
	DeleteIndicesWithPrefix(ctx context.Context, in *DeleteIndicesWithPrefixRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IndexInfo(ctx context.Context, in *IndexInfoRequest, opts ...grpc.CallOption) (*IndexInfoResponse, error)
}

type kVStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewKVStoreClient(cc grpc.ClientConnInterface) KVStoreClient {
	return &kVStoreClient{cc}
}

func (c *kVStoreClient) Put(ctx context.Context, in *IndexKVPair, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KVStore_Put_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreClient) BatchPut(ctx context.Context, opts ...grpc.CallOption) (KVStore_BatchPutClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVStore_ServiceDesc.Streams[0], KVStore_BatchPut_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVStoreBatchPutClient{stream}
	return x, nil
}

type KVStore_BatchPutClient interface {
	Send(*IndexKVPair) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type kVStoreBatchPutClient struct {
	grpc.ClientStream
}

func (x *kVStoreBatchPutClient) Send(m *IndexKVPair) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVStoreBatchPutClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVStoreClient) Lookup(ctx context.Context, in *IndexKVPair, opts ...grpc.CallOption) (*IndexKVPair, error) {
	out := new(IndexKVPair)
	err := c.cc.Invoke(ctx, KVStore_Lookup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreClient) BatchLookup(ctx context.Context, opts ...grpc.CallOption) (KVStore_BatchLookupClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVStore_ServiceDesc.Streams[1], KVStore_BatchLookup_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVStoreBatchLookupClient{stream}
	return x, nil
}

type KVStore_BatchLookupClient interface {
	Send(*IndexKVPair) error
	Recv() (*IndexKVPair, error)
	grpc.ClientStream
}

type kVStoreBatchLookupClient struct {
	grpc.ClientStream
}

func (x *kVStoreBatchLookupClient) Send(m *IndexKVPair) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kVStoreBatchLookupClient) Recv() (*IndexKVPair, error) {
	m := new(IndexKVPair)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVStoreClient) Items(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (KVStore_ItemsClient, error) {
	stream, err := c.cc.NewStream(ctx, &KVStore_ServiceDesc.Streams[2], KVStore_Items_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &kVStoreItemsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type KVStore_ItemsClient interface {
	Recv() (*IndexKVPair, error)
	grpc.ClientStream
}

type kVStoreItemsClient struct {
	grpc.ClientStream
}

func (x *kVStoreItemsClient) Recv() (*IndexKVPair, error) {
	m := new(IndexKVPair)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kVStoreClient) PutStringEnum(ctx context.Context, in *StringEnum, opts ...grpc.CallOption) (*wrapperspb.UInt64Value, error) {
	out := new(wrapperspb.UInt64Value)
	err := c.cc.Invoke(ctx, KVStore_PutStringEnum_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreClient) DeleteIndicesWithPrefix(ctx context.Context, in *DeleteIndicesWithPrefixRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KVStore_DeleteIndicesWithPrefix_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVStoreClient) IndexInfo(ctx context.Context, in *IndexInfoRequest, opts ...grpc.CallOption) (*IndexInfoResponse, error) {
	out := new(IndexInfoResponse)
	err := c.cc.Invoke(ctx, KVStore_IndexInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KVStoreServer is the server API for KVStore service.
// All implementations should embed UnimplementedKVStoreServer
// for forward compatibility
type KVStoreServer interface {
	Put(context.Context, *IndexKVPair) (*emptypb.Empty, error)
	BatchPut(KVStore_BatchPutServer) error
	Lookup(context.Context, *IndexKVPair) (*IndexKVPair, error)
	BatchLookup(KVStore_BatchLookupServer) error
	Items(*wrapperspb.StringValue, KVStore_ItemsServer) error
	PutStringEnum(context.Context, *StringEnum) (*wrapperspb.UInt64Value, error)
	DeleteIndicesWithPrefix(context.Context, *DeleteIndicesWithPrefixRequest) (*emptypb.Empty, error)
	IndexInfo(context.Context, *IndexInfoRequest) (*IndexInfoResponse, error)
}

// UnimplementedKVStoreServer should be embedded to have forward compatible implementations.
type UnimplementedKVStoreServer struct {
}

func (UnimplementedKVStoreServer) Put(context.Context, *IndexKVPair) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedKVStoreServer) BatchPut(KVStore_BatchPutServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchPut not implemented")
}
func (UnimplementedKVStoreServer) Lookup(context.Context, *IndexKVPair) (*IndexKVPair, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lookup not implemented")
}
func (UnimplementedKVStoreServer) BatchLookup(KVStore_BatchLookupServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchLookup not implemented")
}
func (UnimplementedKVStoreServer) Items(*wrapperspb.StringValue, KVStore_ItemsServer) error {
	return status.Errorf(codes.Unimplemented, "method Items not implemented")
}
func (UnimplementedKVStoreServer) PutStringEnum(context.Context, *StringEnum) (*wrapperspb.UInt64Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutStringEnum not implemented")
}
func (UnimplementedKVStoreServer) DeleteIndicesWithPrefix(context.Context, *DeleteIndicesWithPrefixRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIndicesWithPrefix not implemented")
}
func (UnimplementedKVStoreServer) IndexInfo(context.Context, *IndexInfoRequest) (*IndexInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndexInfo not implemented")
}

// UnsafeKVStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVStoreServer will
// result in compilation errors.
type UnsafeKVStoreServer interface {
	mustEmbedUnimplementedKVStoreServer()
}

func RegisterKVStoreServer(s grpc.ServiceRegistrar, srv KVStoreServer) {
	s.RegisterService(&KVStore_ServiceDesc, srv)
}

func _KVStore_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexKVPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVStore_Put_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServer).Put(ctx, req.(*IndexKVPair))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStore_BatchPut_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVStoreServer).BatchPut(&kVStoreBatchPutServer{stream})
}

type KVStore_BatchPutServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*IndexKVPair, error)
	grpc.ServerStream
}

type kVStoreBatchPutServer struct {
	grpc.ServerStream
}

func (x *kVStoreBatchPutServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVStoreBatchPutServer) Recv() (*IndexKVPair, error) {
	m := new(IndexKVPair)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVStore_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexKVPair)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVStore_Lookup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServer).Lookup(ctx, req.(*IndexKVPair))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStore_BatchLookup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KVStoreServer).BatchLookup(&kVStoreBatchLookupServer{stream})
}

type KVStore_BatchLookupServer interface {
	Send(*IndexKVPair) error
	Recv() (*IndexKVPair, error)
	grpc.ServerStream
}

type kVStoreBatchLookupServer struct {
	grpc.ServerStream
}

func (x *kVStoreBatchLookupServer) Send(m *IndexKVPair) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kVStoreBatchLookupServer) Recv() (*IndexKVPair, error) {
	m := new(IndexKVPair)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _KVStore_Items_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KVStoreServer).Items(m, &kVStoreItemsServer{stream})
}

type KVStore_ItemsServer interface {
	Send(*IndexKVPair) error
	grpc.ServerStream
}

type kVStoreItemsServer struct {
	grpc.ServerStream
}

func (x *kVStoreItemsServer) Send(m *IndexKVPair) error {
	return x.ServerStream.SendMsg(m)
}

func _KVStore_PutStringEnum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringEnum)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServer).PutStringEnum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVStore_PutStringEnum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServer).PutStringEnum(ctx, req.(*StringEnum))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStore_DeleteIndicesWithPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteIndicesWithPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServer).DeleteIndicesWithPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVStore_DeleteIndicesWithPrefix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServer).DeleteIndicesWithPrefix(ctx, req.(*DeleteIndicesWithPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVStore_IndexInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVStoreServer).IndexInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KVStore_IndexInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVStoreServer).IndexInfo(ctx, req.(*IndexInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KVStore_ServiceDesc is the grpc.ServiceDesc for KVStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KVStore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shared.KVStore",
	HandlerType: (*KVStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _KVStore_Put_Handler,
		},
		{
			MethodName: "Lookup",
			Handler:    _KVStore_Lookup_Handler,
		},
		{
			MethodName: "PutStringEnum",
			Handler:    _KVStore_PutStringEnum_Handler,
		},
		{
			MethodName: "DeleteIndicesWithPrefix",
			Handler:    _KVStore_DeleteIndicesWithPrefix_Handler,
		},
		{
			MethodName: "IndexInfo",
			Handler:    _KVStore_IndexInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchPut",
			Handler:       _KVStore_BatchPut_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchLookup",
			Handler:       _KVStore_BatchLookup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Items",
			Handler:       _KVStore_Items_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "quanta.proto",
}

const (
	StringSearch_BatchIndex_FullMethodName = "/shared.StringSearch/BatchIndex"
	StringSearch_Search_FullMethodName     = "/shared.StringSearch/Search"
)

// StringSearchClient is the client API for StringSearch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StringSearchClient interface {
	BatchIndex(ctx context.Context, opts ...grpc.CallOption) (StringSearch_BatchIndexClient, error)
	Search(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (StringSearch_SearchClient, error)
}

type stringSearchClient struct {
	cc grpc.ClientConnInterface
}

func NewStringSearchClient(cc grpc.ClientConnInterface) StringSearchClient {
	return &stringSearchClient{cc}
}

func (c *stringSearchClient) BatchIndex(ctx context.Context, opts ...grpc.CallOption) (StringSearch_BatchIndexClient, error) {
	stream, err := c.cc.NewStream(ctx, &StringSearch_ServiceDesc.Streams[0], StringSearch_BatchIndex_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stringSearchBatchIndexClient{stream}
	return x, nil
}

type StringSearch_BatchIndexClient interface {
	Send(*wrapperspb.StringValue) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type stringSearchBatchIndexClient struct {
	grpc.ClientStream
}

func (x *stringSearchBatchIndexClient) Send(m *wrapperspb.StringValue) error {
	return x.ClientStream.SendMsg(m)
}

func (x *stringSearchBatchIndexClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stringSearchClient) Search(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (StringSearch_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &StringSearch_ServiceDesc.Streams[1], StringSearch_Search_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &stringSearchSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StringSearch_SearchClient interface {
	Recv() (*wrapperspb.UInt64Value, error)
	grpc.ClientStream
}

type stringSearchSearchClient struct {
	grpc.ClientStream
}

func (x *stringSearchSearchClient) Recv() (*wrapperspb.UInt64Value, error) {
	m := new(wrapperspb.UInt64Value)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StringSearchServer is the server API for StringSearch service.
// All implementations should embed UnimplementedStringSearchServer
// for forward compatibility
type StringSearchServer interface {
	BatchIndex(StringSearch_BatchIndexServer) error
	Search(*wrapperspb.StringValue, StringSearch_SearchServer) error
}

// UnimplementedStringSearchServer should be embedded to have forward compatible implementations.
type UnimplementedStringSearchServer struct {
}

func (UnimplementedStringSearchServer) BatchIndex(StringSearch_BatchIndexServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchIndex not implemented")
}
func (UnimplementedStringSearchServer) Search(*wrapperspb.StringValue, StringSearch_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}

// UnsafeStringSearchServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StringSearchServer will
// result in compilation errors.
type UnsafeStringSearchServer interface {
	mustEmbedUnimplementedStringSearchServer()
}

func RegisterStringSearchServer(s grpc.ServiceRegistrar, srv StringSearchServer) {
	s.RegisterService(&StringSearch_ServiceDesc, srv)
}

func _StringSearch_BatchIndex_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StringSearchServer).BatchIndex(&stringSearchBatchIndexServer{stream})
}

type StringSearch_BatchIndexServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*wrapperspb.StringValue, error)
	grpc.ServerStream
}

type stringSearchBatchIndexServer struct {
	grpc.ServerStream
}

func (x *stringSearchBatchIndexServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *stringSearchBatchIndexServer) Recv() (*wrapperspb.StringValue, error) {
	m := new(wrapperspb.StringValue)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StringSearch_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(wrapperspb.StringValue)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StringSearchServer).Search(m, &stringSearchSearchServer{stream})
}

type StringSearch_SearchServer interface {
	Send(*wrapperspb.UInt64Value) error
	grpc.ServerStream
}

type stringSearchSearchServer struct {
	grpc.ServerStream
}

func (x *stringSearchSearchServer) Send(m *wrapperspb.UInt64Value) error {
	return x.ServerStream.SendMsg(m)
}

// StringSearch_ServiceDesc is the grpc.ServiceDesc for StringSearch service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StringSearch_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shared.StringSearch",
	HandlerType: (*StringSearchServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchIndex",
			Handler:       _StringSearch_BatchIndex_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Search",
			Handler:       _StringSearch_Search_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "quanta.proto",
}

const (
	BitmapIndex_Update_FullMethodName           = "/shared.BitmapIndex/Update"
	BitmapIndex_BatchMutate_FullMethodName      = "/shared.BitmapIndex/BatchMutate"
	BitmapIndex_BulkClear_FullMethodName        = "/shared.BitmapIndex/BulkClear"
	BitmapIndex_Query_FullMethodName            = "/shared.BitmapIndex/Query"
	BitmapIndex_Join_FullMethodName             = "/shared.BitmapIndex/Join"
	BitmapIndex_Projection_FullMethodName       = "/shared.BitmapIndex/Projection"
	BitmapIndex_CheckoutSequence_FullMethodName = "/shared.BitmapIndex/CheckoutSequence"
	BitmapIndex_TableOperation_FullMethodName   = "/shared.BitmapIndex/TableOperation"
	BitmapIndex_Synchronize_FullMethodName      = "/shared.BitmapIndex/Synchronize"
	BitmapIndex_SyncStatus_FullMethodName       = "/shared.BitmapIndex/SyncStatus"
	BitmapIndex_Commit_FullMethodName           = "/shared.BitmapIndex/Commit"
	BitmapIndex_PartitionInfo_FullMethodName    = "/shared.BitmapIndex/PartitionInfo"
)

// BitmapIndexClient is the client API for BitmapIndex service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BitmapIndexClient interface {
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BatchMutate(ctx context.Context, opts ...grpc.CallOption) (BitmapIndex_BatchMutateClient, error)
	BulkClear(ctx context.Context, in *BulkClearRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Query(ctx context.Context, in *BitmapQuery, opts ...grpc.CallOption) (*QueryResult, error)
	Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error)
	Projection(ctx context.Context, in *ProjectionRequest, opts ...grpc.CallOption) (*ProjectionResponse, error)
	CheckoutSequence(ctx context.Context, in *CheckoutSequenceRequest, opts ...grpc.CallOption) (*CheckoutSequenceResponse, error)
	TableOperation(ctx context.Context, in *TableOperationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Synchronize(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.Int64Value, error)
	SyncStatus(ctx context.Context, in *SyncStatusRequest, opts ...grpc.CallOption) (*SyncStatusResponse, error)
	Commit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PartitionInfo(ctx context.Context, in *PartitionInfoRequest, opts ...grpc.CallOption) (*PartitionInfoResponse, error)
}

type bitmapIndexClient struct {
	cc grpc.ClientConnInterface
}

func NewBitmapIndexClient(cc grpc.ClientConnInterface) BitmapIndexClient {
	return &bitmapIndexClient{cc}
}

func (c *bitmapIndexClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BitmapIndex_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) BatchMutate(ctx context.Context, opts ...grpc.CallOption) (BitmapIndex_BatchMutateClient, error) {
	stream, err := c.cc.NewStream(ctx, &BitmapIndex_ServiceDesc.Streams[0], BitmapIndex_BatchMutate_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &bitmapIndexBatchMutateClient{stream}
	return x, nil
}

type BitmapIndex_BatchMutateClient interface {
	Send(*IndexKVPair) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type bitmapIndexBatchMutateClient struct {
	grpc.ClientStream
}

func (x *bitmapIndexBatchMutateClient) Send(m *IndexKVPair) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bitmapIndexBatchMutateClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bitmapIndexClient) BulkClear(ctx context.Context, in *BulkClearRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BitmapIndex_BulkClear_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) Query(ctx context.Context, in *BitmapQuery, opts ...grpc.CallOption) (*QueryResult, error) {
	out := new(QueryResult)
	err := c.cc.Invoke(ctx, BitmapIndex_Query_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error) {
	out := new(JoinResponse)
	err := c.cc.Invoke(ctx, BitmapIndex_Join_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) Projection(ctx context.Context, in *ProjectionRequest, opts ...grpc.CallOption) (*ProjectionResponse, error) {
	out := new(ProjectionResponse)
	err := c.cc.Invoke(ctx, BitmapIndex_Projection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) CheckoutSequence(ctx context.Context, in *CheckoutSequenceRequest, opts ...grpc.CallOption) (*CheckoutSequenceResponse, error) {
	out := new(CheckoutSequenceResponse)
	err := c.cc.Invoke(ctx, BitmapIndex_CheckoutSequence_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) TableOperation(ctx context.Context, in *TableOperationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BitmapIndex_TableOperation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) Synchronize(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*wrapperspb.Int64Value, error) {
	out := new(wrapperspb.Int64Value)
	err := c.cc.Invoke(ctx, BitmapIndex_Synchronize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) SyncStatus(ctx context.Context, in *SyncStatusRequest, opts ...grpc.CallOption) (*SyncStatusResponse, error) {
	out := new(SyncStatusResponse)
	err := c.cc.Invoke(ctx, BitmapIndex_SyncStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) Commit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BitmapIndex_Commit_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bitmapIndexClient) PartitionInfo(ctx context.Context, in *PartitionInfoRequest, opts ...grpc.CallOption) (*PartitionInfoResponse, error) {
	out := new(PartitionInfoResponse)
	err := c.cc.Invoke(ctx, BitmapIndex_PartitionInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BitmapIndexServer is the server API for BitmapIndex service.
// All implementations should embed UnimplementedBitmapIndexServer
// for forward compatibility
type BitmapIndexServer interface {
	Update(context.Context, *UpdateRequest) (*emptypb.Empty, error)
	BatchMutate(BitmapIndex_BatchMutateServer) error
	BulkClear(context.Context, *BulkClearRequest) (*emptypb.Empty, error)
	Query(context.Context, *BitmapQuery) (*QueryResult, error)
	Join(context.Context, *JoinRequest) (*JoinResponse, error)
	Projection(context.Context, *ProjectionRequest) (*ProjectionResponse, error)
	CheckoutSequence(context.Context, *CheckoutSequenceRequest) (*CheckoutSequenceResponse, error)
	TableOperation(context.Context, *TableOperationRequest) (*emptypb.Empty, error)
	Synchronize(context.Context, *wrapperspb.StringValue) (*wrapperspb.Int64Value, error)
	SyncStatus(context.Context, *SyncStatusRequest) (*SyncStatusResponse, error)
	Commit(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	PartitionInfo(context.Context, *PartitionInfoRequest) (*PartitionInfoResponse, error)
}

// UnimplementedBitmapIndexServer should be embedded to have forward compatible implementations.
type UnimplementedBitmapIndexServer struct {
}

func (UnimplementedBitmapIndexServer) Update(context.Context, *UpdateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedBitmapIndexServer) BatchMutate(BitmapIndex_BatchMutateServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchMutate not implemented")
}
func (UnimplementedBitmapIndexServer) BulkClear(context.Context, *BulkClearRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkClear not implemented")
}
func (UnimplementedBitmapIndexServer) Query(context.Context, *BitmapQuery) (*QueryResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedBitmapIndexServer) Join(context.Context, *JoinRequest) (*JoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}
func (UnimplementedBitmapIndexServer) Projection(context.Context, *ProjectionRequest) (*ProjectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Projection not implemented")
}
func (UnimplementedBitmapIndexServer) CheckoutSequence(context.Context, *CheckoutSequenceRequest) (*CheckoutSequenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckoutSequence not implemented")
}
func (UnimplementedBitmapIndexServer) TableOperation(context.Context, *TableOperationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableOperation not implemented")
}
func (UnimplementedBitmapIndexServer) Synchronize(context.Context, *wrapperspb.StringValue) (*wrapperspb.Int64Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Synchronize not implemented")
}
func (UnimplementedBitmapIndexServer) SyncStatus(context.Context, *SyncStatusRequest) (*SyncStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncStatus not implemented")
}
func (UnimplementedBitmapIndexServer) Commit(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedBitmapIndexServer) PartitionInfo(context.Context, *PartitionInfoRequest) (*PartitionInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PartitionInfo not implemented")
}

// UnsafeBitmapIndexServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BitmapIndexServer will
// result in compilation errors.
type UnsafeBitmapIndexServer interface {
	mustEmbedUnimplementedBitmapIndexServer()
}

func RegisterBitmapIndexServer(s grpc.ServiceRegistrar, srv BitmapIndexServer) {
	s.RegisterService(&BitmapIndex_ServiceDesc, srv)
}

func _BitmapIndex_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_BatchMutate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BitmapIndexServer).BatchMutate(&bitmapIndexBatchMutateServer{stream})
}

type BitmapIndex_BatchMutateServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*IndexKVPair, error)
	grpc.ServerStream
}

type bitmapIndexBatchMutateServer struct {
	grpc.ServerStream
}

func (x *bitmapIndexBatchMutateServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bitmapIndexBatchMutateServer) Recv() (*IndexKVPair, error) {
	m := new(IndexKVPair)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BitmapIndex_BulkClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkClearRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).BulkClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_BulkClear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).BulkClear(ctx, req.(*BulkClearRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BitmapQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).Query(ctx, req.(*BitmapQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_Join_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).Join(ctx, req.(*JoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_Projection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).Projection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_Projection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).Projection(ctx, req.(*ProjectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_CheckoutSequence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckoutSequenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).CheckoutSequence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_CheckoutSequence_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).CheckoutSequence(ctx, req.(*CheckoutSequenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_TableOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).TableOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_TableOperation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).TableOperation(ctx, req.(*TableOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_Synchronize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).Synchronize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_Synchronize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).Synchronize(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_SyncStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).SyncStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_SyncStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).SyncStatus(ctx, req.(*SyncStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_Commit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).Commit(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BitmapIndex_PartitionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PartitionInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BitmapIndexServer).PartitionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BitmapIndex_PartitionInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BitmapIndexServer).PartitionInfo(ctx, req.(*PartitionInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BitmapIndex_ServiceDesc is the grpc.ServiceDesc for BitmapIndex service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BitmapIndex_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shared.BitmapIndex",
	HandlerType: (*BitmapIndexServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _BitmapIndex_Update_Handler,
		},
		{
			MethodName: "BulkClear",
			Handler:    _BitmapIndex_BulkClear_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _BitmapIndex_Query_Handler,
		},
		{
			MethodName: "Join",
			Handler:    _BitmapIndex_Join_Handler,
		},
		{
			MethodName: "Projection",
			Handler:    _BitmapIndex_Projection_Handler,
		},
		{
			MethodName: "CheckoutSequence",
			Handler:    _BitmapIndex_CheckoutSequence_Handler,
		},
		{
			MethodName: "TableOperation",
			Handler:    _BitmapIndex_TableOperation_Handler,
		},
		{
			MethodName: "Synchronize",
			Handler:    _BitmapIndex_Synchronize_Handler,
		},
		{
			MethodName: "SyncStatus",
			Handler:    _BitmapIndex_SyncStatus_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _BitmapIndex_Commit_Handler,
		},
		{
			MethodName: "PartitionInfo",
			Handler:    _BitmapIndex_PartitionInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BatchMutate",
			Handler:       _BitmapIndex_BatchMutate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "quanta.proto",
}
